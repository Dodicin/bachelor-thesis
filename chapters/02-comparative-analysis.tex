\chapter{Comparative Analysis}
\label{chap:comparative-analysis}

The adoption and popularization of DLT has created many new platforms that offer the possibility of building a distributed application.
This creates a peculiar situation in which developers and companies need to decide which platform to choose to develop their applications, with or without any kind of experience in the field.

As these platform's architecture can wildly vary between one and another, it seems to be the case that the industry misses at the moment clear research and understanding of how to separate platforms use cases and practical examples on how such platforms have been employed and why. This is to be expected, as the industry is experiencing rapid growth and evolution, and no standardization and regulamentation has been put into place yet.

This chapter aims to analyze three major DLTs: Ethereum, Corda and Hyperledger. It will provide an overview of each DLT, and then dive into a comparison between the technical aspects of each, in order to showcase the major differences among them.

\section{Ethereum}

Ethereum has one of the biggest following among users and developers, with more than a thousand applications already built on top of the blockchain. It was developed as a permissionless public blockchain where anyone can build application or write smart contracts using its own programming language, Solidity. Ethereum's development team's goal was to provide a generic toolbox for providing support to a wide range of decentralized applications, with a particular emphasis on situations where rapid development time, security and continuous execution of concurring different applications are important.
Ethereum boasts the second highest market cap in the cryptocurrency world, which explains how the blockchain project continues to elicit strong interest from investors.

\subsection{Architecture overview}

Ethereum is a decentralized blockchain platform for building "unstoppable applications", as the whitepaper puts it, while Ether is the cryptocurrency used in the platform.

Ethereum is an open, permissionless blockchain, hence any developer has free access to the platform to build distributed application, using the built-in programming language. These applications are called Dapps. End users interact with the blockchain through these Dapps, with miners creating blocks in which user's transactions are hashed and stored. 

The structure of the Ethereum blockchain is very similar to Bitcoin's. Every node on the network stores a copy of the entire transaction history. With Ethereum, every node also stores the most recent state of each smart contract, in addition to all the transactions. 

There's no centralized control in Ethereum: node operators decide which software their nodes run, miner operatores decide how to mine - solo or in a pool. 

Consensus in the blockchain still uses Proof-of-Work, but the upcoming Casper implementation will introduce Proof-of-Stake, which works similarily to PoW, but as explained in \ref{chap:introduction}, the partecipants in the consensus process are limited to parties which have a real stake in the blockchain, removing the more taxing computation of the hash function with just a digital signature that proves the ownership of the stake in the system.

Ethereum, being a public blockchain, can experience scalability issues. The change to a PoS algorithm might benefit the platform in this regard, but its real effects are still to be explored.

Smart contracts in Ethereum are akin as "autonomous agents", as \cite{ethereumwhitepaper} puts it. They're programs stored and created in the blockchain that execute only when specific criteria are met, and are immutable, once deployed they can't be changed. The code consists in a seres of operations that runs until it reaches the end, an error, or one of the conditions is violated.

Ethereum has the concept of "gas". Gas is the execution fee for the execution of a contract, and usually maps to one step of its computation. Its price is expressed in ether, which represent Ethereum's internal currency. Gas is hence the amount of ether a sender is willing to spend on every unit of gas.

\subsection{Use case}

Ethereum itself is commonly used as a digital currency or digital asset to store and transfer ethers between accounts. Its most common type of application is custom token systems. 

\section{R3 Corda}

Corda is a DLT backed by R3, a consortium made up of many big financial institution. It was developed as a global ledger, with its main goal is to provide an architecture to enable frictionless, well-regulated, reliable and private agreements between parties. Corda was developed specifically on financial use-cases, its main field of application being the financial services industry.

Corda's main goal is to create a global logic ledger, that is, evolving from authoritative systems of records centrally maintained within institutions to a global distribuited authoritative system of records shared between firms, in which all the economic actors will interact in a secure, consistent and private manner.

This has been implemented including the three major visions - as expressed in the \cite{cordawhitepaper}: records managed by the system have to be accessible only on a need-to-know basis by only actors involved in the records; agreements managed by the system and described by their corrispettive contracts gain legitimacy from its over-arching legal prose, which is a mechanism to regulamentate transactions; and to gain adoption across the financial community, portions of the system must be open source and up to industry standards.

\subsection{Architecture overview}

Corda is a private, permissioned distributed ledger. To ensure consistency in a global system where not all data is visible to everyone, Corda relies heavily on secured cryptographic hashes to identify parties and data. 

The core concept model of Corda is built by state objects, representing agreements between two or more parties governed by smart contracts, transactions and flows, which are automatized transaction sequences which enable parties to coordinate actions without a central controller.

A Corda distributed ledger is formed by the union of nodes participating in a Corda network. It differs greatly from a blockchain structure, as the data stored in the distributed ledger isn't accessible to anyone but the interested parties. 

All nodes participating in the network require their identity to be verified. This passage is guaranteed by the "doorman", which is a node regulating entry in the network.

In Corda transactions involve the evolution of state objects between the distributed ledger of the parties involved in it.

In Corda there are two types of consensus: validity consensus and uniqueness consensus, as noted in \ref{sec:consensus}. This type of consensus service means that the guarantor of the consistency of the data isn't the whole architecture itself, but the notary service. This means also that these services are not required to see the full contents of any transaction, significantly improving privacy and scalability of the system compared to other blockchain designs which employ the whole architecture to guarantee consistency.

In Corda there smart contracts are agreements between two parties under the form of programs. These smart contracts and their associated legal prose link business logic and business data, and ensure that financial agreements on the platform are rooted firmly in law and can be enforced in the event of ambiguity.

Distributed applications in Corda are called CorDapps.

\subsection{Use case}

Corda's use case is fundamentally rooted in finance. Use cases include automate auditing of records, payments applications and financial trading applications.

\section{Hyperledger Fabric}

Hyperledger Fabric is a blockchain framework developed by the Linux Foundation. It was intended for developing solutions with a modular architecture, as hyperledger allows components to be plug-and-play. As stated on Hyperledger's website: “Hyperledger is an open source collaborative effort created to advance cross-industry blockchain technologies. It is a global collaboration, hosted by The Linux Foundation, including leaders in finance, banking, Internet of Things, supply chains, manufacturing, and Technology.".
Hyperledger's project tries to incubate different business blockchain technologies and frameworks under what it calls its "Umbrella strategy". Fabric is one of the platforms falling inside the Hyperledger project, and its intended use is that of a generic DLT framwork to enable many different kinds of solutions, not only limited to finance.

\subsection{Architecture overview}

Fabric's blockchain is a private permissioned distributed ledger consisting of many nodes running programs called chaincodes. Chaincodes are Fabric's version of smart contracts, and are the central element as transaction themselves are invoked by chaincodes. Participating in the network are also special validating and non-validating nodes, which are run by white listed organisations and transactors. 

Fabric permissioned network entry is due to its need to guarantee privacy of the operation for participants in the network. This does not exclude the possibility of identification and point-to-point audit done by regulators. Within Hyperledger, content confidentiality is achieved by encrypting the transactions such that only the stakeholders can decrypt and execute them.

Transactions may be of two types, deploy transactions create new chaincode and take a program as parameter. When a deploy transaction executes successfully, the chaincode has been installed “on” the blockchain. Invoke transactions on other hand perform an operation in the context of previously deployed chaincode. An invoke transaction refers to a chaincode and to one of its provided functions. When successful, the chaincode executes the specified function.

Consensus in Hyperledger is pluggable, like Corda, allowing user to select which implementation or algorithm to use during deployment. 

As Fabric is permissioned, it has higher scalability than permissionless distributed ledgers.

\subsection{Use case}

Fabric's use case is broad, as it provides a way to store confidential data that is required for any supply chain. Its use can range from supply chain logistics to trade and financial, or just secure data storing.

\section{Comparison}

From their respective white papers and documentations it becomes obvious that each of these platforms have very different visions and applications in mind.
Corda is driven by concrete use cases from the financial services industry, in contrast, Fabric intends to provide an extendable architecture that can be employed in various different industries. Ethereum also present itself as independant from any specific field of application, but in contrast to Fabric, it's architecture provides a generic platform for transactions, rather than a modular platform for securing data.

It is possible to place these platform on a circular spectrum. On one end, there are Fabric and relatively close, Fabric, which provide a highly flexible and generic platform. However, Ethereum's permissionless nature makes the issues of scalability, cost of performance and privacy arise for use cases that actually demand it. Fabric addresses performance scalability and privacy by its permissioned mode of operation and encryption.
On the other side of the spectrum there's Corda. It has been consciously designed as a DLT for the financial services industries, taking the highly regulated environment into account.
This use case focus provides an architectural design much simpler than Fabric and Ethereum at the cost of flexibility.

The only DLT featuring a cryptocurrency between the three is Ethereum, which uses Ether. Ether is emplyed to pay rewards for nodes that reach consensus. As Fabric and Corda do not reach consensus via mining, they do not need to feature a cryptocurrency in their systems.


The architectures between the three platforms are quite different,hence the comparison will be driven along one shared axis that can highlight each platform's strength and weakness: how data is managed within the system. 

\subsection{Data comparison}

\subsubsection{Data coordination}

Public blockchain do not have anywhere near the same throughput and data processing capabilities as private distributed ledgers. The same holds true for \textbf{Ethereum}, so a comparison on those factors would be certainly be heavily in favor of Corda's or Fabric's distributed ledgers.
Still, Ethereum features a wide range of forks which maintain the same core architecture, but make key changes to increase throughput and processing capabilities, like Quorum. Of note is the change from Proof-of-Work to Proof-of-Stake that is going to be implemented in the Casper version of Ethereum, which will substatially increase throughput via a lighter consensus mechanism.\\

\textbf{Corda}'s architecture relies on a nodal structure and submodules called notaries to help maintain the validity of the network. Each node has a relational database, and their union makes up the distributed storage platform. The data is only accessible by individual parties directly concerned in the transaction, so the actual global distributed ledger isn't accessible by anyone. Coordination of data is carried out through flows, which are programmable and predefined functions that allow communication between nodes. Additionaly, Corda features a layer of identity control (the doorman) which allows for different degrees of access control to the network.
\\

In \textbf{Fabric} the movement of chaincode between clients and the network of distributed peer nodes, along with the transacion mechanisms and transfer of receipts that satisfy endorsement policies is the backbone of the coordination of data in the closed system, while the gossip protocol that propagates transactions within private channels allows for the coordination of larger datasets. The architecture was specifically designed to allow multilateral coordination structures. In this setup, data is distributed across clusters to make up a distributed storage platform. Fabric makes use of a ledger-type structure that deviates from the blockchain structure. It is in fact an hash liked data structure, but these data blocks, while transitioning through what are called deliver events, do not necessarily transition data into a modification of the system's state, rather, the information is stored in a database-like structure with different instances of hashes.
The configuration of the system allows for a transaction throughput that would be expected of the distributed database architecture, but it should be made present that challenges regarding coordination between data and code haven't been completely solved yet.
\\


As a conclusion to this section regarding data coordination, it can be said that Fabric has the edge over the other two platforms thanks to its superior and extensible data coordination toolset. Corda is still defining its capabilities offering coordinating service which are of use specifically to financial institutions, while Ethereum, being designed as a public blockchain, does not have the same raw database processing capabilities as the former two. Forked architecture to Ethereum are designed to close the gap in terms of processing capabilities while allowing the features of a blockchain.

\subsubsection{Trust and data immutability}
Data immutability has been used as a synonymous concept of trust, that is, \textit{since the system is immutable, it is trusted that tampering will not go unnoticed}. It is though important to asses how a trusted system is implemented, to ensure a safe business model. \\


For \textbf{Ethereum}, different layers of trust and immutability have been enstablished in the platform and protocols - in particular for data, within a subprotocol of public blockchain derived state roots from Patricia Merkle Trees. The immutability if the blockchain as a whole is guaranteed because of the number of miners keeping track of the blockchain's ledger. Altering data in a client's ledger will result into a mismatched version between that node and every other node in the network, thus resulting in the tampered node to be ignored by the whole network.
Ethereum and its enterprise forks are hence able to fully substantiate immutability.\\

For \textbf{Fabric}, in order to guarantee that no party in the channel has tampared data in its favor, a sophisticated endorsement policy has been put into place. It is necessary for the client which issues a new transaction to get endorsement from all interested parties, thus ensuring that everyone have a consistent state. It must be understood that the architecture itself, utilizing Apache Kafka for its channel communication protocol, has inherent read/write access to data, so the immutability aspects are somewhat limited to architectural choices.\\

For \textbf{Corda}, the aspect of immutability is preserved differently withing the confines of the system. The trust is in fact enstablished due to the architecture of the system through, the combined acts of the identity verification and regulatory nodes action. Data entries - called states - cannot be modified, but only consumed.\\

Each platform is able to guarantee immutability and trust to various degrees. The edge is given to Ethereum, for which the whole platform is able to guarantee different layers of trust and immutability to the data. Fabric and Corda are somewhat limited to their approach to guarantee immutability and trust due to their architectures, but nevertheless are able to secure data.



\section{Project adoption considerations}

In order to have a robust enough platform that can manage transaction in an easy and secure way, the system must be able to satisfy business requirements for efficient processing of data, trust and immutability of the information.
It is apparante that each platforms can achieve the same goal, to various degrees.

Cost-resource considerations have been made in regards to which technology adopt for the project, and Corda has been chosen as the technology to use for the development of the prototype for this project work. 
This is due to its simpler architectural design, which would require a definitely shorter amount of resources - time, developers - to understand compared to its competitors, and to the focus on financial use cases, which the underlying project this project work takes place in is set up.
The issues of scalability, privacy and efficiency have also been taken in consideration, thus ruling out a public, permissionless environment. 

